#!/usr/bin/env python3
"""
ImageDisk comment editor

This program displays, then edits, the comment header of an .IMD disk image.

Usage:

    imdc.py file.imd

Comments must be fully contained within code page 437.

The original ImageDisk (v1.18) generates files with this header format:

    IMD v.vv: dd/mm/yyyy hh:mm:ss          (ASCII Header)
    Comment (ASCII only - unlimited size)  (NOTE:  You can TYPE a .IMD)
    1A byte - ASCII EOF character          (file to see header/comment)

Applesauce (as of v1.60) generates .IMD files with this header:

    IMD generated by Applesauce Fast Imager 2022-01-26T02:36:56.082Z

followed by the `0x1A` termination byte.

This utility was designed to work around Applesauce's lack of support for
the .IMD comment field.

As Dave Dunfield's IMDA.COM rejects files with headers > 8192 bytes, and Keir
Fraser's disk-utilities library rejects images with headers > 4096 bytes,
this utility limits the header to 4096 bytes.
"""

import os
import shutil
import subprocess
import sys
import tempfile
from hashlib import sha256
from pathlib import Path
from typing import BinaryIO


def file_as_bytes(file: BinaryIO) -> bytes:
    with file:
        return file.read()


def read_header(file: BinaryIO) -> bytes:
    buf = file.read(4096 + 1)
    assert buf[0:4] == b"IMD ", "ImageDisk header not found!"
    # truncate at 0x1a if present
    try:
        buf = buf[: buf.index(b"\x1a")]
    except ValueError:
        assert 0, "End of comment not found in first 4KB!"
    return buf


def find_editor() -> str:
    if "EDITOR" in os.environ and os.environ["EDITOR"]:
        return Path(shutil.which(os.environ["EDITOR"]))
    else:
        if sys.platform == "win32":
            return ["cmd.exe", "/C", "start"]
        elif sys.platform == "darwin":
            # "open "
            return ["open"]
        else:
            for cmd in ["nano", "pico", "vi"]:
                if shutil.which(cmd):
                    return [Path(shutil.which(cmd))]
            raise RuntimeError(
                "No text editor could be found! Set EDITOR in environment."
            )


def to_cp437_printable(comment: str) -> str:
    return comment.decode("cp437").translate(
        {
            0x0A: "\u00B6\n",
            0x0D: "",  # 0x0d: u"\u266A",
            0x01: "\u263A",
            0x02: "\u263B",
            0x03: "\u2665",
            0x04: "\u2666",
            0x05: "\u2663",
            0x06: "\u2660",
            0x07: "\u2022",
            0x08: "\u25D8",
            0x09: "\u25CB",
            0x0B: "\u2642",
            0x0C: "\u2640",
            0x0E: "\u266B",
            0x0F: "\u263C",
            0x10: "\u25BA",
            0x11: "\u25C4",
            0x12: "\u2195",
            0x13: "\u203C",
            0x14: "\u00B6",
            0x15: "\u00A7",
            0x16: "\u25AC",
            0x17: "\u21A8",
            0x18: "\u2191",
            0x19: "\u2193",
            0x1A: "\u2192",
            0x1B: "\u2190",
            0x1C: "\u221F",
            0x1D: "\u2194",
            0x1E: "\u25B2",
            0x1F: "\u25BC",
            0x7F: "\u2302",
        }
    )


def print_comment(comment: str):
    print("=" * 72)
    # TODO: support cp1252?
    print(to_cp437_printable(comment))
    print("=" * 72)


# -------------------

assert sys.version_info >= (3, 8)

if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <image.IMD>")
    exit(1)

src = Path(sys.argv[1])
with open(src, "rb") as imd:
    header = read_header(imd)

    print(f"{len(header)} byte header found:\n")
    print_comment(header)

    fd, temp = tempfile.mkstemp(suffix=".txt", prefix="imd-comment-", text=True)
    os.close(fd)
    temp = Path(temp)
    temp.write_bytes(header)
    command = find_editor()
    command.append(str(temp))
    proc = subprocess.run(command)
    input(f"Opening editor for {temp}, press Enter/Return when done...")

    new_comment = temp.read_bytes()
    os.unlink(temp)

    if new_comment == header:
        print("No comment change! Exiting.")
        exit(0)
    elif len(new_comment) > 4095:
        print("Comment too large - must be 4KB or less! Exiting.")
        exit(1)
    elif new_comment[0:4] != b"IMD ":
        print("Comment must start with 'IMD '! Refusing to change header.")
        exit(1)

    print(f"New {len(new_comment)} byte comment as follows:")
    print_comment(new_comment)

# copy for safety, remove when done
copy = Path(tempfile.gettempdir()) / src.name

shutil.copy2(src, copy)
# let's be paranoid
assert copy.stat().st_size == src.stat().st_size
src_hash = sha256(file_as_bytes(open(src, "rb"))).digest()
copy_hash = sha256(file_as_bytes(open(copy, "rb"))).digest()
assert src_hash == copy_hash

# pre-calculate expected hash
new_hash = sha256()
new_hash.update(new_comment)
new_hash.update(b"\x1a")

with open(copy, "rb") as imd:
    # verify we can read the copy still
    imd.read(len(header) + 1)
    with open(src, "wb") as out:
        out.write(new_comment)
        out.write(b"\x1a")

        while chunk := imd.read(8192):
            new_hash.update(chunk)
            out.write(chunk)
shutil.copystat(copy, src)
new_hash = new_hash.digest()
dst_hash = sha256(file_as_bytes(open(src, "rb"))).digest()
assert dst_hash == new_hash
copy.unlink()

print("")
